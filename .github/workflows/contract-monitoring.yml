name: AI Contract Drift Monitor

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run drift check daily at 9 AM UTC
    - cron: '0 9 * * *'
  workflow_dispatch: # Allow manual trigger

jobs:
  contract-tests:
    name: Contract Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Cache Playwright browsers
      uses: actions/cache@v4
      id: playwright-cache
      with:
        path: ~/.cache/ms-playwright
        key: playwright-browsers-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
        
    - name: Install Playwright browsers
      if: steps.playwright-cache.outputs.cache-hit != 'true'
      run: npx playwright install chromium --with-deps
      
    - name: Run contract tests
      run: npm run test:contracts
      
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: test-results/

  drift-check:
    name: Drift Detection
    runs-on: ubuntu-latest
    needs: contract-tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run drift check
      id: drift
      env:
        # AI Configuration (GROQ)
        AI_ENABLED: true
        AI_GATEWAY_URL: https://api.groq.com/openai/v1/chat/completions
        AI_API_KEY: ${{ secrets.AI_API_KEY || secrets.GROQ_API_KEY }}
        AI_GROUNDED_ONLY: false
        AI_MAX_TOKENS: 1500
        
        # GitHub Actions context (for logs only, notification sent separately)
        GITHUB_SERVER_URL: ${{ github.server_url }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        
        # Security Guardrails
        SAFE_HTTP_METHODS: GET,HEAD,POST
        MAX_QPS: 1
        MAX_CONCURRENCY: 2
        HTTP_TIMEOUT_MS: 8000
        
        # Drift Configuration
        DRIFT_SEVERITY_GATE: major
        SNAPSHOT_UPDATE_MODE: PR_ONLY
        
        # Metrics
        METRICS_PORT: 9091
      run: |
        echo "üöÄ Running drift check..."
        npm run drift 2>&1 | tee drift_output.log || true
        
        # Save full console output for Teams notification
        cat drift_output.log > .drift_report.txt
        
        # Extract drift status from logs
        if grep -q "MAJOR changes detected" drift_output.log; then
          echo "severity=MAJOR" >> $GITHUB_OUTPUT
          echo "has_drift=true" >> $GITHUB_OUTPUT
          echo "status=üö® BLOCKING" >> $GITHUB_OUTPUT
        elif grep -q "MINOR changes detected" drift_output.log; then
          echo "severity=MINOR" >> $GITHUB_OUTPUT
          echo "has_drift=true" >> $GITHUB_OUTPUT
          echo "status=‚ö†Ô∏è Alert Only" >> $GITHUB_OUTPUT
        else
          echo "severity=NONE" >> $GITHUB_OUTPUT
          echo "has_drift=false" >> $GITHUB_OUTPUT
          echo "status=‚úÖ All Good" >> $GITHUB_OUTPUT
        fi
        
        # Count affected APIs
        # Try multiple methods to extract the count
        AFFECTED_COUNT=$(grep -oP "Drift detected in \K\w+" drift_output.log | wc -l | tr -d ' \n' || echo "0")
        if [ "$AFFECTED_COUNT" = "0" ] || [ -z "$AFFECTED_COUNT" ]; then
          # Fallback: count lines with "Affected APIs"
          AFFECTED_COUNT=$(grep -c "Affected APIs:" drift_output.log 2>/dev/null | tr -d ' \n' || echo "0")
        fi
        if [ "$AFFECTED_COUNT" = "0" ] || [ -z "$AFFECTED_COUNT" ]; then
          # Fallback: if drift detected, assume at least 1
          if grep -q "MAJOR changes detected\|MINOR changes detected" drift_output.log 2>/dev/null; then
            AFFECTED_COUNT="1"
          else
            AFFECTED_COUNT="0"
          fi
        fi
        
        # Clean any remaining whitespace/newlines
        AFFECTED_COUNT=$(echo "$AFFECTED_COUNT" | tr -d ' \n\r\t')
        
        echo "affected_apis=$AFFECTED_COUNT" >> $GITHUB_OUTPUT
        
        # Always succeed (don't fail the job)
        exit 0
      
    - name: Send Email Notification
      if: always()
      env:
        SMTP_HOST: ${{ secrets.SMTP_HOST }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USER: ${{ secrets.SMTP_USER }}
        SMTP_PASS: ${{ secrets.SMTP_PASS }}
        SMTP_FROM: ${{ secrets.SMTP_FROM }}
        EMAIL_TO: ${{ secrets.EMAIL_TO }}
      run: |
        if [ -z "$SMTP_HOST" ] || [ -z "$EMAIL_TO" ]; then
          echo "‚ö†Ô∏è Email not configured, skipping notification"
          exit 0
        fi
        
        SEVERITY="${{ steps.drift.outputs.severity }}"
        STATUS="${{ steps.drift.outputs.status }}"
        AFFECTED="${{ steps.drift.outputs.affected_apis }}"
        RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        # Fallback for affected_apis if empty
        if [ -z "$AFFECTED" ]; then
          if [ "$SEVERITY" = "MAJOR" ] || [ "$SEVERITY" = "MINOR" ]; then
            AFFECTED="1"
          else
            AFFECTED="0"
          fi
        fi
        
        # Extract full AI analysis
        if [ -f .drift_report.txt ]; then
          FULL_MESSAGE=$(awk '/^============================================================$/{flag=!flag; next} flag' .drift_report.txt)
          FULL_MESSAGE=$(echo "$FULL_MESSAGE" | tail -n +2)
          
          if [ -z "$FULL_MESSAGE" ] || [ "${#FULL_MESSAGE}" -lt 50 ]; then
            FULL_MESSAGE=$(grep -A 100 "üìù Summary:" .drift_report.txt | grep -v "\[" | head -80 || echo "Analysis in progress")
          fi
        else
          FULL_MESSAGE="No analysis available"
        fi
        
        # Build title based on severity
        if [ "$SEVERITY" = "MAJOR" ]; then
          TITLE="üö® API Drift Detected - MAJOR"
          COLOR="#FF0000"
        elif [ "$SEVERITY" = "MINOR" ]; then
          TITLE="‚ö†Ô∏è API Drift Detected - MINOR"
          COLOR="#FFA500"
        else
          TITLE="‚úÖ API Contracts Status - All Good"
          COLOR="#00FF00"
        fi
        
        # Create HTML email
        cat > email_body.html <<EOF
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
            .header { background: ${COLOR}; color: white; padding: 20px; border-radius: 5px; }
            .content { padding: 20px; background: #f5f5f5; margin: 20px 0; border-radius: 5px; }
            .details { background: white; padding: 15px; border-left: 4px solid ${COLOR}; margin: 15px 0; }
            .fact { padding: 5px 0; }
            .fact strong { display: inline-block; width: 200px; }
            .button { display: inline-block; padding: 10px 20px; background: ${COLOR}; color: white; text-decoration: none; border-radius: 5px; margin: 10px 0; }
            pre { white-space: pre-wrap; word-wrap: break-word; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>${TITLE}</h1>
          </div>
          <div class="content">
            <pre>${FULL_MESSAGE}</pre>
          </div>
          <div class="details">
            <div class="fact"><strong>üÜî Run ID:</strong> ${{ github.run_id }}</div>
            <div class="fact"><strong>üìä Severity:</strong> ${SEVERITY}</div>
            <div class="fact"><strong>‚ö†Ô∏è APIs Affected:</strong> ${AFFECTED}</div>
            <div class="fact"><strong>üö¶ Status:</strong> ${STATUS}</div>
            <div class="fact"><strong>‚è∞ Timestamp:</strong> $(date -u +"%Y-%m-%d %H:%M:%S UTC")</div>
          </div>
          <a href="${RUN_URL}" class="button">üîç View Execution Details</a>
        </body>
        </html>
        EOF
        
        # Send email using Python
        python3 <<PYTHON
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        
        with open('email_body.html', 'r') as f:
            html_content = f.read()
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = '${TITLE}'
        msg['From'] = '${SMTP_FROM}'
        msg['To'] = '${EMAIL_TO}'
        
        msg.attach(MIMEText(html_content, 'html'))
        
        with smtplib.SMTP('${SMTP_HOST}', int('${SMTP_PORT}')) as server:
            server.starttls()
            server.login('${SMTP_USER}', '${SMTP_PASS}')
            server.send_message(msg)
        
        print('‚úÖ Email notification sent successfully')
        PYTHON
        
        echo "‚úÖ Email notification sent: $TITLE"
      
    - name: Check for changes
      id: changes
      run: |
        if git diff --quiet snapshots/latest.json; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi
        
    - name: Read PR body
      id: pr_body
      if: steps.changes.outputs.has_changes == 'true'
      run: |
        if [ -f .pr_body.md ]; then
          echo "PR body file found"
          cat .pr_body.md
        else
          echo "No PR body file found, using default"
        fi
        
    - name: Create Pull Request for snapshot changes
      if: steps.changes.outputs.has_changes == 'true'
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: "chore: update API snapshots [automated]"
        branch: "drift/snapshot-update-${{ github.run_id }}"
        delete-branch: true
        title: "üö® API Drift Detected - Snapshot Update Required"
        body-path: .pr_body.md
        labels: |
          drift-detection
          automated-pr
          api-monitoring
        assignees: ${{ github.actor }}
        
    - name: Upload snapshots
      uses: actions/upload-artifact@v4
      with:
        name: api-snapshots
        path: snapshots/
        retention-days: 90
        
    - name: Send notification summary
      if: always()
      run: |
        echo "## üìä Drift Check Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ${{ steps.changes.outputs.has_changes == 'true' && '‚ö†Ô∏è Changes Detected' || '‚úÖ All Good' }}" >> $GITHUB_STEP_SUMMARY
        echo "**APIs Monitored:** $(cat snapshots/latest.json | jq 'keys | length')" >> $GITHUB_STEP_SUMMARY
        if [ "${{ steps.changes.outputs.has_changes }}" == "true" ]; then
          echo "**Changes:** Snapshots updated and PR created" >> $GITHUB_STEP_SUMMARY
        else
          echo "**Changes:** No changes detected" >> $GITHUB_STEP_SUMMARY
        fi
        echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîó Quick Links" >> $GITHUB_STEP_SUMMARY
        echo "- üì∏ [View Snapshots](https://github.com/${{ github.repository }}/tree/main/snapshots)" >> $GITHUB_STEP_SUMMARY
        echo "- üìù [Latest Commit](https://github.com/${{ github.repository }}/commit/${{ github.sha }})" >> $GITHUB_STEP_SUMMARY

  metrics:
    name: Prometheus Metrics & Health Check
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Start Prometheus metrics server
      run: |
        npm run metrics &
        METRICS_PID=$!
        echo "METRICS_PID=$METRICS_PID" >> $GITHUB_ENV
        sleep 10
        
    - name: Health check and metrics validation
      run: |
        # Health check
        curl -f http://localhost:9091/health || exit 1
        
        # Metrics validation
        METRICS_RESPONSE=$(curl -s http://localhost:9091/metrics)
        echo "Metrics endpoint responding: ‚úÖ"
        
        # Check for key metrics
        if echo "$METRICS_RESPONSE" | grep -q "process_cpu_seconds_total"; then
          echo "CPU metrics found: ‚úÖ"
        else
          echo "CPU metrics missing: ‚ùå"
          exit 1
        fi
        
        if echo "$METRICS_RESPONSE" | grep -q "nodejs_eventloop_lag_seconds"; then
          echo "Event loop metrics found: ‚úÖ"
        else
          echo "Event loop metrics missing: ‚ùå"
          exit 1
        fi
        
    - name: Save metrics snapshot
      run: |
        # Save metrics to file with timestamp
        TIMESTAMP=$(date -u +%Y%m%d_%H%M%S)
        curl -s http://localhost:9091/metrics > metrics_${TIMESTAMP}.txt
        curl -s http://localhost:9091/health > health_${TIMESTAMP}.json
        
        # Create summary file
        echo "# Metrics Snapshot - $(date -u)" > metrics_summary.md
        echo "" >> metrics_summary.md
        echo "## üìä System Health" >> metrics_summary.md
        cat health_${TIMESTAMP}.json >> metrics_summary.md
        echo "" >> metrics_summary.md
        echo "" >> metrics_summary.md
        echo "## üìà Full Metrics" >> metrics_summary.md
        echo "See metrics_${TIMESTAMP}.txt for complete Prometheus metrics" >> metrics_summary.md
        
    - name: Upload metrics artifacts
      uses: actions/upload-artifact@v4
      with:
        name: metrics-snapshot-${{ github.run_id }}
        path: |
          metrics_*.txt
          health_*.json
          metrics_summary.md
        retention-days: 30
        
        
    - name: Stop metrics server
      if: always()
      run: |
        if [ ! -z "$METRICS_PID" ]; then
          kill $METRICS_PID 2>/dev/null || true
        fi
